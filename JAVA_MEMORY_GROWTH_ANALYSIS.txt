═══════════════════════════════════════════════════════════════
  Java内存增长分析与解决方案
  Java Memory Growth Analysis
═══════════════════════════════════════════════════════════════

问题: Java内存从2.6GB上升到5.2GB
日期: 2025-11-21
场景: 运行全量评估任务（39任务×100次试验）

═══════════════════════════════════════════════════════════════
  内存增长分析
═══════════════════════════════════════════════════════════════

【初始状态】
  • Python: 1.7GB
  • Java:   2.6GB
  • 总计:   4.3GB ✅ 正常

【当前状态】
  • Java:   5.2GB ⚠️ 上升了2.6GB
  • 增长率: 100% (翻倍)

【判断】

⚠️  需要关注，但未达到危险水平

原因分析:
  1. Minecraft世界数据累积
  2. MineDojo saves目录未清理
  3. Java堆内存正常增长
  4. 可能存在轻微内存泄漏

═══════════════════════════════════════════════════════════════
  内存增长原因
═══════════════════════════════════════════════════════════════

【1. Minecraft世界数据累积】

每个trial会生成:
  • 世界区块数据: ~50-100MB
  • 实体数据: ~10-20MB
  • 玩家数据: ~5-10MB

如果运行了很多trial:
  • 10个trial: ~500MB-1GB
  • 50个trial: 2.5-5GB ← 您当前可能的情况
  • 100个trial: 5-10GB

【2. MineDojo saves目录】

MineDojo会保存世界数据到:
  ~/.minedojo/saves/

如果没有定期清理:
  • Java进程会保留引用
  • 内存无法释放
  • 持续增长

【3. Java堆内存特性】

Java堆内存会:
  • 按需增长（不会主动缩小）
  • 达到-Xmx设置的最大值
  • 垃圾回收后不一定释放给OS

【4. MineRL环境特性】

MineRL/MineDojo:
  • 每个trial创建新世界
  • 旧世界数据可能未完全清理
  • 长时间运行会累积

═══════════════════════════════════════════════════════════════
  内存增长预测
═══════════════════════════════════════════════════════════════

【当前情况】

假设您正在运行: all_tasks (39任务×100次)

已完成任务数估算:
  当前内存: 5.2GB
  初始内存: 2.6GB
  增长: 2.6GB
  
  如果每个任务增长: 2.6GB / X任务
  
可能情况:
  • 如果完成了5个任务: 每任务增长520MB ⚠️
  • 如果完成了10个任务: 每任务增长260MB ✅
  • 如果完成了20个任务: 每任务增长130MB ✅

【完整运行预测】

如果内存持续线性增长:

场景1: 保守估计（每任务增长130MB）
  • 39任务完成: 2.6GB + (130MB × 39) ≈ 7.7GB ✅ 可接受

场景2: 中等估计（每任务增长260MB）
  • 39任务完成: 2.6GB + (260MB × 39) ≈ 12.7GB ⚠️ 需要关注

场景3: 激进估计（每任务增长520MB）
  • 39任务完成: 2.6GB + (520MB × 39) ≈ 22.8GB 🚨 可能OOM

═══════════════════════════════════════════════════════════════
  风险评估
═══════════════════════════════════════════════════════════════

【当前风险级别】⚠️ 中等

✅ 暂时安全:
  • 5.2GB仍在合理范围内
  • 大部分服务器有足够内存
  • 评估功能正常运行

⚠️ 需要监控:
  • 内存持续增长
  • 可能在后期出现问题
  • 建议采取预防措施

🚨 危险信号（如果出现）:
  • Java > 10GB
  • 系统内存不足
  • 出现OOM错误
  • 评估进程被kill

═══════════════════════════════════════════════════════════════
  解决方案
═══════════════════════════════════════════════════════════════

【方案1: 定期清理saves目录（推荐）】

MineDojo会保存世界到 ~/.minedojo/saves/

立即清理:
  # 检查saves目录大小
  du -sh ~/.minedojo/saves/
  
  # 清理旧的世界数据
  rm -rf ~/.minedojo/saves/*
  
  # 或者只保留最近的
  find ~/.minedojo/saves/ -type d -mtime +1 -exec rm -rf {} \;

自动清理脚本:
  # 在评估过程中定期清理
  while true; do
    sleep 3600  # 每小时
    echo "清理MineDojo saves..."
    rm -rf ~/.minedojo/saves/*
  done &

【方案2: 限制Java堆内存】

设置最大堆大小，防止无限增长:

方法1: 环境变量
  export JAVA_OPTS="-Xmx4G -Xms2G"
  bash scripts/run_evaluation.sh ...

方法2: 修改启动脚本
  # 在scripts/run_evaluation.sh开头添加
  export JAVA_OPTS="-Xmx4G -Xms2G"

参数说明:
  • -Xms2G: 初始堆大小2GB
  • -Xmx4G: 最大堆大小4GB
  • 建议Xmx设置为期望的上限

【方案3: 分批运行（最稳妥）】

不要一次运行all_tasks，分批运行:

第1批: harvest_tasks (13个任务)
  bash scripts/run_evaluation.sh \
    --config config/eval_tasks_comprehensive.yaml \
    --task-set harvest_tasks \
    --n-trials 100 --enable_report
  
  # 完成后重启，释放内存

第2批: combat_tasks (10个任务)
  bash scripts/run_evaluation.sh \
    --config config/eval_tasks_comprehensive.yaml \
    --task-set combat_tasks \
    --n-trials 100 --enable_report

第3批: techtree_tasks (14个任务)
  ...

每批之间:
  • 进程自动结束，释放所有内存
  • 清理saves目录
  • 重新开始，内存重置

【方案4: 启用环境重建（实验性）】

修改steve1_evaluator.py，每N个trial重建环境:

找到这段代码:
  """
  if trial_idx > 0:
      logger.info(f"  ♻️  重新创建环境...")
      ...
  """

取消注释，启用环境重建。

但这会:
  • 降低评估速度
  • 可能引入其他问题
  • 不推荐作为首选方案

═══════════════════════════════════════════════════════════════
  立即行动建议
═══════════════════════════════════════════════════════════════

【情况1: 如果还在运行中（内存<8GB）】

✅ 继续运行，但开始监控:

1. 打开新终端，监控内存:
   watch -n 300 'free -h && echo "---" && ps aux | grep java | grep -v grep'

2. 定期清理saves:
   while true; do
     sleep 3600
     rm -rf ~/.minedojo/saves/*
     echo "$(date): Cleaned saves"
   done &

3. 记录进度，以便中断后恢复

【情况2: 如果内存持续快速增长（>8GB）】

⚠️ 建议停止当前运行，改为分批:

1. Ctrl+C 停止当前评估

2. 清理内存:
   rm -rf ~/.minedojo/saves/*
   # 等待Java进程结束

3. 分批运行:
   bash scripts/run_evaluation.sh \
     --config config/eval_tasks_comprehensive.yaml \
     --task-set harvest_tasks \
     --n-trials 100 --enable_report

【情况3: 如果出现OOM或被kill】

🚨 立即采取措施:

1. 清理环境:
   rm -rf ~/.minedojo/saves/*
   pkill -9 java

2. 限制Java堆:
   export JAVA_OPTS="-Xmx6G -Xms2G"

3. 必须分批运行:
   每次只运行一个小任务集

═══════════════════════════════════════════════════════════════
  监控脚本
═══════════════════════════════════════════════════════════════

创建监控脚本监控Java内存:

cat > monitor_java_memory.sh << 'SCRIPT'
#!/bin/bash

LOG_FILE="java_memory_log.txt"
ALERT_THRESHOLD_GB=8

while true; do
    # 获取Java进程内存（MB）
    java_mem_mb=$(ps aux | grep java | grep -v grep | awk '{print $6}' | head -1)
    
    if [ -n "$java_mem_mb" ]; then
        java_mem_gb=$(echo "scale=2; $java_mem_mb / 1024 / 1024" | bc)
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        
        echo "$timestamp - Java内存: ${java_mem_gb}GB" | tee -a $LOG_FILE
        
        # 检查是否超过阈值
        if [ $(echo "$java_mem_gb > $ALERT_THRESHOLD_GB" | bc) -eq 1 ]; then
            echo "⚠️  警告: Java内存超过${ALERT_THRESHOLD_GB}GB!" | tee -a $LOG_FILE
            
            # 自动清理saves
            rm -rf ~/.minedojo/saves/*
            echo "已清理MineDojo saves目录" | tee -a $LOG_FILE
        fi
    fi
    
    sleep 600  # 每10分钟检查一次
done
SCRIPT

chmod +x monitor_java_memory.sh

# 后台运行
./monitor_java_memory.sh &

# 查看日志
tail -f java_memory_log.txt

═══════════════════════════════════════════════════════════════
  长期优化建议
═══════════════════════════════════════════════════════════════

【代码层面】

在evaluate_task或_run_single_trial中添加定期清理:

def _clean_saves_periodically(self):
    """定期清理MineDojo saves目录"""
    saves_path = Path.home() / ".minedojo" / "saves"
    if saves_path.exists():
        import shutil
        try:
            shutil.rmtree(saves_path)
            saves_path.mkdir(parents=True, exist_ok=True)
            logger.info("✓ 已清理MineDojo saves目录")
        except Exception as e:
            logger.warning(f"清理saves失败: {e}")

每隔N个trial调用:
  if trial_idx % 10 == 0:
      self._clean_saves_periodically()

【系统层面】

1. 使用cgroup限制内存:
   cgexec -g memory:eval_group python ...

2. 使用Docker容器隔离:
   docker run --memory=8g ...

3. 定时重启评估进程

═══════════════════════════════════════════════════════════════
  预期内存使用曲线
═══════════════════════════════════════════════════════════════

【正常情况】

启动:      2.6GB
5个任务:   3.5GB (+900MB)  ✅
10个任务:  4.5GB (+1.9GB)  ✅
20个任务:  6GB   (+3.4GB)  ⚠️
30个任务:  7.5GB (+4.9GB)  ⚠️
39个任务:  8-9GB (+5.4-6.4GB) ⚠️

如果清理saves:
  • 内存增长会减缓
  • 可能保持在6-8GB

【异常情况】

如果每个任务增长500MB+:
  • 15个任务就会超过10GB 🚨
  • 需要立即干预
  • 分批运行或限制堆

═══════════════════════════════════════════════════════════════
  常见问题
═══════════════════════════════════════════════════════════════

Q: 5.2GB算正常吗？
A: ⚠️ 偏高但可接受。
   - 如果是运行了10+个任务，正常
   - 如果只运行了2-3个任务，异常
   - 建议监控，看是否继续增长

Q: 什么时候需要干预？
A: • Java内存 > 8GB
   • 增长速度 > 500MB/任务
   • 系统内存不足
   • 出现警告或错误

Q: 分批运行会影响结果吗？
A: ✅ 完全不影响
   - 每批的结果独立保存
   - 最后可以合并报告
   - 反而更稳定可靠

Q: 如何恢复中断的评估？
A: 评估框架会跳过已完成的任务
   - 重新运行相同命令即可
   - 检查results/目录确认进度

═══════════════════════════════════════════════════════════════
  总结
═══════════════════════════════════════════════════════════════

【当前状态】⚠️ 需要关注

Java内存: 5.2GB
  • 暂时安全
  • 需要监控
  • 建议采取预防措施

【推荐行动】

立即:
  ✓ 清理saves目录: rm -rf ~/.minedojo/saves/*
  ✓ 开始监控内存增长
  ✓ 记录当前进度

如果内存>8GB:
  ⚠️ 考虑停止并分批运行

长期:
  ✓ 使用分批运行策略
  ✓ 定期清理saves
  ✓ 限制Java堆大小

【最佳实践】

对于长时间评估（39任务×100次）:
  1. 分批运行（推荐）
  2. 定期清理saves
  3. 监控内存使用
  4. 设置合理的Java堆限制

═══════════════════════════════════════════════════════════════

维护者: AIMC项目团队
最后更新: 2025-11-21

